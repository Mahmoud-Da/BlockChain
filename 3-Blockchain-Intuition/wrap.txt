*** 5. Plan of Attack  ***
# Blockchain Course – Lecture Notes (Introduction & Plan of Attack)

## Purpose of the Section

* To provide a **structured plan** for learning blockchain.
* Blockchain itself is **not inherently complex**, but it contains many interrelated components of varying complexity.
* Understanding requires placing components in the **right order** for faster mastery.

## Learning Roadmap (Plan of Attack)

1. **High-Level Overview of Blockchain**

   * Establish basic fundamentals.
   * Serves as the foundation for all later topics.

2. **Cryptography & SHA-256 Hash Algorithm**

   * Role of cryptography in blockchains.
   * Explanation of SHA-256 (no deep mathematics required).
   * Understanding how blocks are cryptographically linked.
   * Additional reading available for deeper insights.

3. **Immutable Ledger**

   * Compare blockchain with traditional ledgers.
   * Understand the **first layer of security** blockchain provides in record keeping.

4. **Distributed Peer-to-Peer Networks**

   * How distribution of the ledger enhances security.
   * Introduces a **second layer of security** through decentralization.

5. **Mining (Two-Part Tutorial)**

   * **Part 1:** Mechanics of mining, nonce parameter.
   * **Part 2:** The cryptographic puzzle.
   * Learn why miners need large computational power and specialized rigs.

6. **Byzantine Fault Tolerance (BFT)**

   * The problem of the Byzantine Generals.
   * Applications: blockchain, airplanes, nuclear facilities, International Space Station.
   * Importance in distributed systems.

7. **Consensus Protocol (Two-Part Tutorial)**

   * **Part 1:** How consensus protects against attackers.
   * **Part 2:** How consensus resolves competing chains and ensures blockchain evolution despite global distribution and network lag.

8. **Blockchain Demo (Final Tutorial)**

   * Visual demonstration combining all concepts.
   * Summary of the entire section in one integrated example.

## Structure & Expectations

* Total: **10 tutorials** (not including this introductory lecture).
* Each tutorial builds on the previous one.
* Emphasis on **visual demonstrations** for clarity.
* Requires patience, but designed to be engaging and fun.

## Outcomes

* Gain **solid understanding** of blockchain fundamentals.
* Ability to **discuss blockchain confidently** with others (knowledge above \~90% of the population).
* Preparation for practical tutorials where you will build your first blockchain step by step.

---

*** 6. What is a Blockchain ***
# Blockchain Course – Lecture Notes (What is a Blockchain? High-Level Overview)

## Origins of Blockchain

* **Stuart Haber and W. Scott Stornetta (1991)**

  * Published a paper: *"How to Time-Stamp a Digital Document"*.
  * Contained most of the core ideas behind what is now called blockchain.
* **Satoshi Nakamoto**

  * Later formalized the concept and introduced the term "blockchain."

## Definition

* **Wikipedia definition:**
  “A blockchain is a continuously growing list of records, called blocks, which are linked and secured using cryptography.”
* This definition is general but provides a starting point.

## Structure of a Block

* **Components of a block:**

  1. **Data** – Information stored (e.g., “Hello world”).
  2. **Previous Hash** – Reference to the hash of the block before it.
  3. **Own Hash** – Unique digital fingerprint of the block.

* **Hash (digital fingerprint):**

  * Derived from the block’s data and previous hash.
  * Always 64 characters long.
  * Provides a unique, tamper-detectable identity for the block.

## The Genesis Block

* The **first block** in a blockchain.
* Called the **Genesis Block**.
* Characteristics:

  * Always remains block number one (cannot be replaced).
  * Contains data but **no previous hash** (represented as all zeros).
  * Has its own hash.

## Linking Blocks Together

* Each block references the **previous block’s hash**.
* This creates a **cryptographic chain** of blocks.
* Example:

  * Block 2’s `previous hash` = Block 1’s `hash`.
  * Block 3’s `previous hash` = Block 2’s `hash`.

Blockchain Structure (High-Level View)
-------------------code----------------------

[ Block 1 (Genesis) ]        [ Block 2 ]                 [ Block 3 ]
Data: Hello World            Data: Some Data             Data: More Data
Prev Hash: 0000...           Prev Hash: hash1            Prev Hash: hash2
Hash: hash1                  Hash: hash2                 Hash: hash3

      |--------------------->|--------------------------->|
             linked                  linked

-------------------code----------------------
Explanation:
- Each block stores Data, Prev Hash, and Hash.
- "Prev Hash" always equals the Hash of the previous block.
- The Genesis Block has no previous hash (set to 0000...).
- Changing any block changes its hash and breaks the chain.


## Importance of Cryptographic Linking

* If data in a block is tampered with:

  * Its hash (fingerprint) changes.
  * The next block’s `previous hash` no longer matches.
  * This breaks the chain and signals tampering.
* Therefore, blockchain ensures **integrity and immutability**.

## Key Takeaway

* A blockchain is essentially a **chain of blocks linked by hashes**.
* Tampering with any block invalidates the chain.
* This cryptographic linking provides **security and trust** in the system.

## What’s Next

* Future tutorials will cover:

  * Hash cryptography (next lesson).
  * Mining.
  * Distributed peer-to-peer networks.
  * Consensus protocols.
  * Immutable ledgers.

## Recommended Reading

* *“How to Time-Stamp a Digital Document”* by **Haber and Stornetta (1991)**.
* Link available in the course notes.

---

*** 7. Understanding SHA256 - Hash ***
---

# Lecture Notes: Cryptography and SHA256 in Blockchain

## Introduction

* Topic: **Cryptography in Blockchain**
* Focus: The role of the **SHA256 Hash algorithm**.
* SHA256 = one of the **core building blocks** of blockchain technology.

---

## Fingerprint Analogy

* Every person has a **unique fingerprint** (low probability of duplicates: \~1 in 60 million).
* Fingerprints are identifiers, widely used in forensics to identify individuals.
* Idea: apply the same concept to **digital documents**.
* Digital fingerprint = **SHA256 Hash**.

---

## What is SHA256?

* **SHA** = Secure Hash Algorithm.
* **256** = number of bits (output size).
* Always produces a **64-character hexadecimal hash**.

  * Hexadecimal = digits (0–9) + letters (A–F).
  * Each character = 4 bits → 64 × 4 = 256 bits.
* Created by the **NSA**, but the algorithm is **public and open**.
* Widely used in:

  * Password storage
  * Document verification
  * Blockchain

---

## Properties of SHA256

1. **One-way function**

   * Cannot reverse-engineer the original data from the hash.
   * Similar to fingerprints: cannot recreate a person from a fingerprint.

2. **Deterministic**

   * Same input → always same output.
   * Example: entering identical data always returns the same hash.

3. **Fast computation**

   * Hash must be computed quickly for efficiency in blockchain processes.

4. **Avalanche Effect**

   * Small changes in input = **completely different hash**.
   * Example: changing a single character drastically changes the output.
   * Crucial for blockchain integrity.

5. **Collision Resistance**

   * A “collision” = two different inputs producing the same hash.
   * In theory possible (pigeonhole principle), but extremely rare.
   * Must withstand **artificially created collisions** (important for security).
   * Prevents document forgery (e.g., property ownership fraud).

---

## Demonstration (Tools Provided)

* Toolkit: [tools.superdatascience.com/blockchain/hash](https://tools.superdatascience.com/blockchain/hash)
* Created by Anders Brownworth (Anders94).
* Features:

  * Input any data → see resulting SHA256 hash.
  * Shows determinism and avalanche effect.
  * Works on **any digital input** (text, images, videos, executables, etc.).

---

## Additional Notes on Collisions

* **Pigeonhole Principle**: finite number of hashes vs. infinite possible inputs → collisions inevitable in theory.
* Acceptable when rare, but **deliberately engineered collisions** are a risk.
* A secure hash algorithm must **resist intentional collision attacks**.

---

## Summary of SHA256 Requirements

For a hash algorithm to be useful in blockchain, it must be:

1. One-way
2. Deterministic
3. Fast to compute
4. Demonstrate avalanche effect
5. Collision-resistant

---

## Recommended Reading

* **“On the Secure Hash Algorithm Family”**

  * Chapter 1 of *Cryptography in Context*
  * Authors: Penard & Werkhoven
  * Explains SHA256 in detail

---

## Conclusion

* SHA256 is the **digital fingerprint system** powering blockchain.
* Its properties ensure **security, integrity, and reliability**.
* Mastering SHA256 is crucial for understanding blockchain concepts such as mining and consensus protocols.

---

*** 8. Immutable Ledger ***
# Lecture Notes: Immutable Ledger in Blockchain

## Review of Previous Lesson

* Previously discussed **hash cryptography**.
* Learned how blocks in a blockchain are **cryptographically linked** together, forming the chain.

## What is the Immutable Ledger?

* **Immutable ledger** = data recorded in the blockchain cannot be changed.
* Once information is added, altering it becomes extremely difficult.

## Real-World Example: Property Ownership

1. **Traditional System**

   * Buying a house involves paying money in exchange for a **title deed**.
   * Ownership must be **registered with a government authority** (e.g., city council).
   * Registration is recorded in a **ledger** (either a physical book or digital file).
   * Issues:

     * Physical ledgers can be lost, stolen, or tampered with.
     * Digital ledgers (e.g., spreadsheets) are easy to edit.
     * Errors and corruption are common.
     * Natural disasters can destroy records.
2. **Problems**

   * If a ledger entry is altered or deleted, ownership can be disputed.
   * Example: Bank of America mistakenly foreclosed homes during the 2008 financial crisis due to unreliable records.
   * Example: In places like Tahiti, natural disasters destroy property records, making ownership unclear.
   * World Bank estimates **70% of the world’s population** lacks proper property titling systems.

## Blockchain Solution

* **Blockchain as a property ledger**:

  * Each transaction (buying/selling) = new block in the chain.
  * Tampering with one block breaks the cryptographic links with all subsequent blocks.
  * To successfully alter one record, every block after it must also be changed—making tampering impractical.
* Compared to traditional systems:

  * More secure than paper or spreadsheets.
  * Harder to alter records.
  * Ensures data integrity over time.

## Use Cases Beyond Property

* **Property ledgers**: leading real-world example of blockchain adoption outside finance.
* **Diamonds**: tracking origin, sales, and ownership history.
* **Other physical assets**: any system currently using ledgers can be moved to blockchain.

## Example: UK Property Transactions

* \~100,000 residential property transactions per month.
* Only includes transactions valued **above £40,000**.
* Breakdown:

  * \~3,000 per day.
  * \~140 per hour.
  * \~1 transaction every 30 seconds.
* High transaction volume increases the likelihood of errors in traditional ledgers.
* Blockchain can solve these issues by providing a secure, immutable record.

## Key Takeaways

* **Immutable ledger** means data recorded in blockchain is permanent and tamper-resistant.
* Provides greater trust in systems that depend on ledgers (property, assets, records).
* Governments are already considering blockchain for property title management.
* Potential to revolutionize not just finance, but also asset tracking, governance, and institutional record-keeping.

## Suggested Reading

* *"Blockchain Economy: A Beginner's Guide to Institutional Cryptoeconomics"* (popular article on Medium, \~10,000 claps).

  * Discusses how blockchain impacts government, society, and the economy.

---


*** 9. Distributed P2P Network ***
# Lecture Notes: Distributed Peer-to-Peer Networks in Blockchain

**Instructor:** Hello, and welcome back to the course on Blockchain.

**Today's Topic:** Distributed Peer-to-Peer (P2P) Networks

---

## 1. Recap of Previous Topics

* **Hash Cryptography:** Ensures integrity of each block.
* **Immutable Ledger:** Makes it very difficult to change past records, improving reliability.
* **Problem Identified:** Even with blockchain immutability, if a single authority maintains the ledger:

  * A malicious actor could attempt to alter multiple blocks for personal gain.
  * Accidental errors (input mistakes) could break cryptographic links, and restoring data would be difficult.

---

## 2. The Problem

Two main concerns:

1. **Malicious attack:** Someone could attempt to change blocks to forge the ledger.
2. **Accidental error:** Data might be corrupted, intentionally or not, and recovering the original data is challenging.

---

## 3. Solution: Distributed Peer-to-Peer Networks

### Key Concept:

* Instead of maintaining the blockchain in a single authority’s server, it is **copied across multiple computers** (peers) in a network.

### Structure:

* Each computer holds a copy of the blockchain.
* Peers are interconnected.
* Updates to the blockchain propagate throughout the network.
* Examples: A government property ledger could exist on thousands or millions of computers.

---

## 4. How Blockchain Works in a P2P Network

* **Adding a New Block:**

  1. A transaction (e.g., property purchase) creates a new block.
  2. The new block is propagated to all peers in the network.
  3. Each peer updates its blockchain copy.
* **Handling Hacks or Errors:**

  * If a hacker modifies a block on one computer:

    * Cryptographic links reveal the tampering.
    * The majority of peers have the original blockchain.
    * The altered blockchain is automatically corrected by syncing with the majority.
  * **Majority Rule:** To successfully alter the blockchain, an attacker would need to compromise **more than 50% of peers simultaneously**.

    * Example: In a 6-computer network, at least 4 must be hacked at once.
    * In larger networks (10,000 computers), 5,001 would need to be hacked simultaneously, which is practically impossible.

---

## 5. Benefits of Distributed P2P Networks

1. **Resilience:** No single point of failure.
2. **Security:** Attacks require majority control, which is extremely difficult.
3. **Trustless Environment:** Participants don’t need to know or trust each other.
4. **Automatic Recovery:** Mistakes or malicious changes are corrected through consensus.
5. **Enhanced Transparency:** Blockchain data is distributed, verifiable, and synchronized across peers.

---

## 6. Layers of Security in Blockchain

1. **Hash Cryptography:** Ensures data integrity.
2. **Distributed P2P Networks:** Prevent single-point attacks.
3. **Consensus Protocols:** Further reinforce reliability and trust.
4. Additional layers (covered in later modules) enhance security further.

---

## 7. Recommended Reading

* **Article:** “The Meaning of Decentralization” by Vitalik Buterin (Ethereum Founder)

  * Explains differences between:

    * Centralization vs. Decentralization
    * Distributed Systems vs. Decentralized Systems
  * Introduces:

    * Logical Decentralization
    * Political Decentralization
    * Architectural Decentralization
  * Helpful for understanding debates around blockchain structure.

---

**Conclusion:**
Distributed peer-to-peer networks add an additional layer of security to blockchain systems, ensuring data integrity, automatic recovery, and trust in a trustless environment. They make malicious attacks practically impossible without controlling the majority of the network.

---

*** 10. How Mining Works: The Nonce ***
# Blockchain Mining – Part 1

## 1. Context and Progress

* Previous topics covered:

  * Hash cryptography
  * Immutable ledger
  * Distributed peer-to-peer networks
* Current focus: **Mining** (Part 1 of 2)

## 2. The Blockchain Block Structure

* **Fields in a block:**

  1. **Block Number** – sequential identifier of the block.
  2. **Data** – contains multiple transactions, not just one.

     * Example transactions (using “hadcoins” cryptocurrency):

       * Sent Hadelin 500 hadcoins
       * Bought something for 100 hadcoins
       * Hadelin sent Joe 70 hadcoins
  3. **Previous Hash** – cryptographic link to the previous block; essential for blockchain integrity.
  4. **Current Hash** – calculated using: hash(block number + data + previous hash)


## 3. Why Mining is Needed

* At first glance, generating a hash seems simple.
* Question arises: Why are hundreds of thousands of nodes and mining rigs consuming massive resources globally?
* The answer lies in a special field called **nonce**.

## 4. The Nonce

* **Definition:** “Number used only once.”
* Purpose: Allows miners to vary the block hash without altering block number, previous hash, or transaction data (to maintain immutability).
* Nonce gives **flexibility** in generating different hash values.

### 4.1 Hash Control

* Components affecting the hash now:

  * Block number
  * Data
  * Previous hash
  * Nonce
* Changing the nonce alters the resulting hash while keeping other fields intact.

### 4.2 Avalanche Effect

* Small changes in input (like incrementing the nonce by 1) drastically change the hash output.
* This ensures that even minimal modifications produce completely different hash values.

### 4.3 Example

* Nonce = 0 → hash  = A23F1A1B1D2E3F1
* Nonce = 19 → hash = F2A522CA24B42AF
* Nonce = 20 → hash = 2AC22D63CD0EFF5
* Nonce can range up to billions, giving miners a large space to explore for valid hashes.

PS:
hexadecimal numbers only [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F ]

## 5. Key Takeaways

* **Mining** involves changing the nonce to vary the block hash.
* Block integrity is maintained because:

  * Block number is fixed
  * Previous hash is fixed
  * Transaction data is immutable
* The nonce is the primary tool miners use to find a hash that satisfies certain conditions (covered in Part 2).

## 6. Next Steps

* Part 2 of the tutorial will explain:

  * Why miners compete
  * How computational power and electricity are used in mining
  * The full mining process in action

---

*** 11. How Mining Works: The Cryptographic Puzzle  ***

---

# Blockchain Mining – Part 2

## 1. Recap

* Previous tutorial covered:

  * Block structure (block number, data, previous hash, nonce)
  * Nonce as the only field that can be modified to vary the block hash
* Current focus: How mining works in practice

---

## 2. Hashes as Numbers

* **Hash values** are not just strings; they are **numbers**.
* Hashes are expressed in **hexadecimal**: digits 0–9 and letters A–F.

  * Hexadecimal allows a compact representation of large numbers.
  * Each hex digit represents a value from 0 to 15.
* Hexadecimal can be converted to **decimal** for a clearer numerical understanding.
* Hashes of blocks are treated as numerical values that can be compared, ordered, and mapped.

---

## 3. The Pool of Hashes

* Conceptualize all possible hash values as a **pool**, ordered from smallest to largest:

  * Smallest hash → all digits `0`
  * Largest hash → all digits `F`
* Every block hash occupies a position in this ordered map.

In **hexadecimal (base 16)**:

* Each character represents a value from **0 to 15**.
* Breakdown:

| Hex Digit | Decimal Value |
| --------- | ------------- |
| 0         | 0             |
| 1         | 1             |
| 2         | 2             |
| 3         | 3             |
| 4         | 4             |
| 5         | 5             |
| 6         | 6             |
| 7         | 7             |
| 8         | 8             |
| 9         | 9             |
| A         | 10            |
| B         | 11            |
| C         | 12            |
| D         | 13            |
| E         | 14            |
| F         | 15            |

- So each **hexadecimal character encodes 4 bits** (since $2^4 = 16$).

* Example:

  * Hex `F` → decimal `15` → binary `1111`
  * Hex `2` → decimal `2` → binary `0010`


Sure! Let’s break down how a full **64-character SHA-256 hash** represents a huge decimal number.

---

### 1. SHA-256 Hash

* SHA-256 produces a **256-bit hash**.
* Each hex character encodes **4 bits**, so:

-------------------code----------------------
256 \text{ bits} \div 4 \text{ bits per hex character} = 64 \text{ hex characters}
-------------------code----------------------

Example (hexadecimal hash, 64 chars):

-------------------code----------------------
3F7A1B2C9E0D4F8A1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF
-------------------code----------------------

---

### 2. Converting Hex to Decimal

* Each hex character has a decimal value (0–15).
* To get the decimal value of the full hash, interpret it as a **base-16 number**:

-------------------code----------------------
\text{Decimal value} = \sum_{i=0}^{63} (\text{hex digit}_i \times 16^{63-i})
-------------------code----------------------

* This produces a **very large number**, typically hundreds of digits in decimal.

---

### 3. Visual Example (smaller hash)

Take a 4-character hex hash for simplicity: `1A3F`

1. Convert each hex digit to decimal:

   * `1` → 1
   * `A` → 10
   * `3` → 3
   * `F` → 15

2. Calculate decimal value:

-------------------code----------------------
1 \times 16^3 + 10 \times 16^2 + 3 \times 16^1 + 15 \times 16^0
-------------------code----------------------

-------------------code----------------------
= 1 \times 4096 + 10 \times 256 + 3 \times 16 + 15 \times 1
-------------------code----------------------

-------------------code----------------------
= 4096 + 2560 + 48 + 15 = 6719
-------------------code----------------------

So `1A3F` in hex = `6719` in decimal.

---

### 4. Full SHA-256 Hash

* If you apply the same principle to a **64-character hash**, the decimal number is **enormous**, roughly:

-------------------code----------------------
\text{up to } 10^{77} \text{ digits}
-------------------code----------------------

* That’s why miners treat hashes as **numbers** when comparing them to the target in mining.

---

---

## 4. Mining Target

* The blockchain sets a **target** for miners: only hashes **below the target** are valid.
* Hashes above the target are **rejected**.
* The target is arbitrary, meant only to create a **computational challenge** for miners.
* **Leading zeros** provide a practical way to visualize and understand the target:

  * More leading zeros → smaller hash → harder to find.
  * Example: a target requiring **four leading zeros** in the hash.

---

## 5. Mining Process

1. **Immutable fields**:

   * Block number: fixed
   * Transaction data: fixed
   * Previous hash: fixed
2. **Modifiable field**:

   * Nonce: can be changed freely to vary the hash of the block
3. **Procedure**:

   * Miners iteratively try different nonce values.
   * Each nonce produces a different hash due to the **avalanche effect**.
   * Avalanche effect: a small change in nonce produces a completely different hash.
   * Miners **cannot predict** the hash outcome, ensuring fairness.
4. **Winning condition**:

   * Find a nonce such that the resulting hash is below the target.
   * This successful nonce is called the **golden nonce**.
5. **Reward**:

   * Miner who finds the golden nonce first can add the block to the blockchain and earn a reward.


EX:
Hash Pool (from smallest to largest)
-------------------code----------------------
---------------------------------------------------
| 0000...0  | <- Smallest possible hash
|           |
|   ...     |
| 00A3F2C1  | <- Hash from Nonce = 10
|           |
| TARGET -->| <- Target (hash must be below this to be valid)
| 0F12AB34  | <- Hash from Nonce = 42
|           |
| 1A3F5B7C  | <- Hash from Nonce = 100
|           |
| FFFF...F  | <- Largest possible hash
---------------------------------------------------
-------------------code----------------------
Target: 00FFFFFF  (hash must be below this to be valid)

Mining Example:
- Nonce = 10 → Hash = 00A3F2C1  => below target? YES → valid
- Nonce = 42 → Hash = 0F12AB34  => below target? NO → invalid
- Nonce = 100 → Hash = 1A3F5B7C => below target? NO → invalid

Explanation:
- Miners iteratively change the nonce until a hash below the target is found.
- The nonce that produces a valid hash is called the "golden nonce."

---

## 6. Importance of Hashing Algorithm

* Mining relies on the **SHA-256 hashing algorithm**:

  * Produces unpredictable hashes
  * Prevents reverse-engineering or shortcutting the process
  * Previous algorithms like SHA-1, MD4, MD5 have been cracked
* SHA-256 ensures that mining remains a **secure cryptographic puzzle**.

---

## 7. Key Points

* Mining is essentially **guessing the correct nonce** to produce a hash below the target.
* Computational power is required due to the difficulty of finding valid nonces.
* Avalanche effect guarantees unpredictability and fairness.
* The cryptographic puzzle ensures that blockchain integrity is maintained.

---

## 8. Next Steps

* Module 2 will cover:

  * How transactions are structured within blocks
  * Practical blockchain coding exercises
  * Additional fields involved in mining
* This foundation prepares learners to understand the practical and computational aspects of blockchain mining.

---

*** 12. Byzantine Fault Tolerance ***
---

# Byzantine Fault Tolerance (BFT)

## 1. Introduction

* **Concept**: Byzantine fault tolerance (BFT) is the ability of a decentralized system to reach consensus despite faulty or malicious participants.
* **Origin**: Illustrated through the **Byzantine Generals Problem**.
* **Importance**: Essential in blockchains and other decentralized or safety-critical systems (e.g., airplanes, rockets, nuclear plants).

---

## 2. The Byzantine Generals Problem

* **Scenario**:

  * Several generals surround a castle.
  * They must **agree (consensus)** on whether to **attack or retreat**.
  * Success depends on a **majority agreement**.
  * A traitor may attempt to disrupt consensus.

* **Key Conditions**:

  * Communication is limited to **oral messages**.
  * Any general, including the commander, **could be a traitor**.
  * Generals must use a **pre-agreed algorithm** to reach consensus.

---

## 3. Example with Four Generals

### Case A: A Lieutenant is the Traitor

1. Commander issues the order (e.g., “Attack”).
2. Generals **relay** the command to others.
3. Traitor lies, saying the commander ordered “Retreat.”
4. Each general compares messages:

   * Two say “Attack,” one says “Retreat.”
   * Majority = Attack.
5. **Result**: Consensus is achieved, army wins.

### Case B: The Commander is the Traitor

1. Commander sends conflicting orders (e.g., two “Attack,” one “Retreat”).
2. Generals relay messages to each other.
3. Each receives two similar messages vs. one conflicting message.
4. They follow the **majority**.
5. **Result**: Consensus is still reached.

---

## 4. Tolerance Limit

* With **one traitor**, consensus is possible.
* With **two traitors** among four generals: consensus is **impossible**.
* General rule (from the 1982 paper):

  * The system works if **≤ 1/3 of participants are traitors**.
  * Example: With 10 generals, consensus possible if ≤ 3 are traitors.

---

## 5. Applications of BFT

### Blockchain

* Protects against malicious nodes or attackers.
* Consensus protocols (to be discussed later) rely on BFT principles.

### Other Systems

* **Airplanes**: Multiple sensors provide input; system tolerates faulty readings.
* **Nuclear power plants**: Safety requires tolerance to component failures.
* **Rockets & ISS docking**: Must withstand radiation or signal jamming.

---

## 6. References

* **Original Paper**: Lamport, Shostak, and Pease (1982), *The Byzantine Generals Problem*.
* **Further Reading**: Georgios Konstantopoulos, *Understanding Blockchain Fundamentals, Part 1: Byzantine Fault Tolerance* (Medium article).

---

## 7. Key Takeaway

Byzantine fault tolerance ensures that decentralized systems (including blockchains) can continue functioning correctly as long as fewer than one-third of participants act maliciously or fail.

---
