*** 16. Step 1 ***
# Practical Activities Course: Blockchain, Cryptocurrency, Smart Contracts

## Instructors

* Adla (second instructor for the course)

## Course Overview

This course contains **three main modules**:

1. **Module 1: Blockchain**

   * Create a general blockchain.
   * Each block can store arbitrary data.

2. **Module 2: Cryptocurrency**

   * Start from the blockchain created in Module 1.
   * Decentralize it across multiple computers/servers.
   * Create a cryptocurrency called **AT Coin**.

3. **Module 3: Smart Contracts**

   * Create a smart contract for a simulated ICO of 1 million AT Coins.

---

## Required Tools

* **Anaconda IDE** (recommended for Python 3.6 development)

  * Includes Spyder IDE and Jupyter Notebook.
  * Useful for practical tutorials.
* **Python 3.6** (not Python 2.7, due to syntax compatibility)
* **Packages**:

  * `flask` (for creating web-based blockchain API)
  * `requests` (for sending requests such as mining blocks or adding transactions)
* **Postman**

  * User-friendly HTTP client for interacting with the blockchain.
  * Alternative: cURL (less user-friendly for beginners)

---

## Step 1: Installing Anaconda

1. Go to the [Anaconda website](https://www.anaconda.com/) and download the installer.
2. Select the installer for your operating system (Windows, Linux, Mac).
3. Choose **Python 3.6** version.
4. Run the installer:

   * Click through `Continue → Continue → Agree → Install`.
   * Wait for installation to complete.

---

## Step 2: Launching Anaconda

* **Windows/Linux:** Find Anaconda Navigator in the program list.
* **Mac:** Find Anaconda Navigator in Applications.
* Launch it and wait for initialization.

### Inside Anaconda

* Work in the **root environment** (no need for a virtual environment for this course).
* Recommended IDE for practical use: **Spyder**

  * Jupyter Notebook is better for combining code with LaTeX/mathematical notation.
* Launch Spyder through Anaconda Navigator.

---

## Step 3: Preparing Your Project

1. Create a main folder, e.g., `blockchain_a-z`, with three subfolders:

   * `Module 1` → Blockchain
   * `Module 2` → Cryptocurrency
   * `Module 3` → Smart Contracts
2. Create a new Python file:

   * `File → New File`
   * Save as `blockchain.py` inside `Module 1` folder.
3. Close default `10.py` file in Spyder (not needed).
4. This `blockchain.py` will contain the implementation of the **general blockchain**.

---

## Step 4: Next Steps

1. Install the necessary Python packages:

   * `flask`
   * `requests`
2. Set up **Postman** to interact with your blockchain API.
3. Begin implementing the general blockchain in `blockchain.py`:

   * Create plain blocks
   * Enable adding arbitrary data to blocks

**Next Tutorial:** Installing packages and preparing Postman for blockchain interaction.

---

*** 17. Step 2 ***

# Lecture Notes – Installing Tools for Blockchain Development

## Introduction

* Before creating the blockchain, two tools must be installed:

  1. **Flask** – A web framework to build a web application containing the blockchain.
  2. **Postman** – An HTTP client providing a user-friendly interface for interacting with the blockchain (instead of CURL).

---

## Installing Flask

* **Command:**

-------------------code----------------------
pip install Flask==0.12.2
-------------------code----------------------

  PS: we use "pipenv install" instead

* **For Mac/Linux:**
  Open a terminal and run the command.

* **For Windows:**

  * Click the Windows button (bottom left).
  * Search for *Anaconda* → *Anaconda Prompt*.
  * Run the command inside the prompt.

* **Notes:**

  * If Flask is already installed, it will show up.
  * If not, installation is quick.

---

## Installing Postman

* **Steps:**

  1. Open a browser and search for *Postman*.
  2. Click the official link: *Postman API Development Environment*.
  3. Download for your operating system (Mac, Windows, Linux).
  4. The download begins automatically (small file size).
  5. Locate the downloaded file (e.g., *Postman OSX* on Mac).
  6. Double-click to unzip and run the installer.

* **First Use:**

  * Sign up with Google or create an account.
  * Once signed in, the main interface shows available request types.

---

## Using Postman

* **Request Types Used:**

  * **GET Request:**

    * Retrieve the state of the blockchain.
    * Mine a block.
  * **POST Request:**

    * Add a new transaction (will be used in module two).
    * Requires a JSON file with:

      * Sender address
      * Receiver address
      * Amount of AT coins

* **Note:**

  * Module one uses only **GET requests** (mining blocks, checking blockchain state).
  * Module two introduces **POST requests** for transactions (with AT coin).

---

## Conclusion

* Flask and Postman are now installed.
* With these tools ready, development of the blockchain (module one) can begin.

---

*** 18. Step 3 ***
---

# Lecture Notes – Building the Blockchain (Part 1)

## Overview

* The blockchain will be built in **two parts**:

  1. **Part 1** – Build the blockchain architecture (class and structure).
  2. **Part 2** – Add two functions:

     * Function to get the state of the blockchain (display in Postman).
     * Function to mine a new block.

* In this lecture: focus on **Part 1 – Building the blockchain architecture**.

---

## Libraries Imported

1. **datetime** – To generate timestamps for each block (date and time of creation/mining).
2. **hashlib** – To hash blocks using SHA-256 (ensures data integrity).
3. **json** – To encode blocks before hashing (using `json.dumps`).
4. **Flask** – Web framework to create the blockchain application.

   * `Flask` class: creates the web application.
   * `jsonify`: formats responses into JSON for Postman.

---

## Purpose of `jsonify`

* Converts responses into JSON format for Postman.
* Used in:

  * Displaying the blockchain state.
  * Returning details of a newly mined block (index, proof, previous hash, and message).

---

## Why Use a Class?

* A **class** is the best way to build a scalable and organized system like a blockchain.
* Benefits of classes:

  * Encapsulate **properties**, **functions**, and **methods**.
  * Allow creation of multiple objects (instances).
  * Provide structure and modularity.
* Example: a self-driving car class with properties (speed, sensors) and methods (move forward, turn, brake).
* Similarly, a blockchain class will encapsulate all the core components.

---

## Defining the Blockchain Class

* Start with:

  -------------------code----------------------
  class Blockchain:
  -------------------code----------------------
* Inside the class, include all blockchain components:

  * **Genesis block** (first block of the chain).
  * **Chain initialization** (list of blocks).
  * **`create_block` method** (to add new blocks).
  * Additional tools to ensure blockchain security and integrity.

---

## `__init__` Method

* Always defined when working with classes.
* Syntax:

  -------------------code----------------------
  def __init__(self):
  -------------------code----------------------
* Argument: `self` (refers to the object instance created from the class).
* Responsibilities:

  1. **Initialize the chain**:

     -------------------code----------------------
     self.chain = []
     -------------------code----------------------

     * Creates an empty list to store blocks.
  2. **Create the Genesis block**:

     -------------------code----------------------
     self.create_block(proof=1, previous_hash='0')
     -------------------code----------------------

     * **Proof:** Arbitrary starting value (commonly `1`).
     * **Previous hash:** Arbitrary since no block precedes the Genesis block (commonly `'0'`).
     * Must be a string (because SHA-256 accepts encoded strings).

---

## Current Progress

* The blockchain is initialized with:

  * An empty list (`self.chain`).
  * A Genesis block (created using the `create_block` method).

* Next step (in future lecture): implement the `create_block` method to add blocks.

---


*** 19. Step 4 **
---

# Lecture Notes: Create Block Function in Blockchain

## Recap from Previous Tutorial

* Initialized blockchain with two variables:

  * `self.chain`: an empty list that will store mined blocks.
  * Genesis block: created with `create_block` function using:

    * `proof = 1`
    * `previous_hash = "0"`

---

## Purpose of the Create Block Function

* Used **right after mining a block**.
* Creates and appends a new block to the blockchain.
* Key difference from `mine_block` function:

  * `mine_block`: finds the **proof of work** (solves the puzzle).
  * `create_block`: takes that proof and previous hash to form and store the new block.

---

## Function Arguments

* `self`: to access blockchain object variables.
* `proof`: obtained after solving the proof of work.
* `previous_hash`: the hash of the previous block, linking blocks together.

---

## Block Structure

Each block is a dictionary with four essential keys:

1. **Index**

   * Position of the block in the chain.
   * `index = len(self.chain) + 1`

2. **Timestamp**

   * Exact time when the block is mined.
   * Obtained using:

     -------------------code----------------------
     str(datetime.datetime.now())
     -------------------code----------------------

3. **Proof**

   * The proof of work found by solving the algorithm.
   * Passed as an argument to the function.

4. **Previous Hash**

   * The hash of the previous block.
   * Ensures continuity and immutability of the blockchain.

---

## Optional Additional Key

* **Data**:

  * Can store transactions or other information.
  * Example: `"data": "some text or structured content"`
  * This will be expanded in Module 2 (cryptocurrency transactions).

---

## Appending and Returning the Block

* After defining the block:

  * Append it to the chain with `self.chain.append(block)`
  * Return the block so its information can be displayed (e.g., in Postman).

---

## Workflow Summary

1. Mine block → solve proof of work.
2. Call `create_block(proof, previous_hash)` → generate block.
3. Append new block to blockchain.
4. Return block details for display.

---


*** 20. Step 5 ***
Here’s the lecture organized into clean notes:

---

# Lecture Notes: `get_previous_block` Method

## Purpose

* The `get_previous_block` method is used to **retrieve the last block** in the current blockchain.
* Provides an easy way to reference the most recent block when creating or validating new blocks.

---

## Function Definition

* Method name: `get_previous_block` (can be named differently, but this is standard).
* Arguments:

  * **`self`**: needed to access `self.chain`, the list of all blocks in the blockchain.

---

## Implementation

* Access the blockchain list: `self.chain`.
* Retrieve the last element of the list using index `-1`.
* Return this last block directly.

---

## Code Example

-------------------code----------------------
class Blockchain:

    def __init__(self):
        self.chain = []
        # Genesis block is created in another method

    def get_previous_block(self):
        return self.chain[-1]
-------------------code----------------------

---

## Importance

* Provides the **previous hash** of the latest block, which is required when creating a new block.
* Ensures each new block is properly linked to the last one in the chain.

---

## Next Step

* In the next tutorial:

  * Implement the **Proof of Work (PoW)** function.
  * This defines the computational puzzle miners must solve.
  * Once solved, it returns the **proof**, which together with the **previous hash** (from `get_previous_block`) is used to create a new block.

---

*** 21. Step 6 ***
---

# Lecture Notes: Proof of Work Function

## Concept of Proof of Work

* **Definition**: A proof of work (PoW) is the number that miners must find to mine a new block.
* **Core principle**:

  * Hard to find → prevents miners from easily mining endless blocks (and devaluing cryptocurrency).
  * Easy to verify → allows other miners to quickly check validity.
* **Purpose**:

  * Ensures scarcity and value of mined blocks.
  * Provides the `proof` argument required by the `create_block` function.

---

## Function Design

* Function name: `proof_of_work`
* Arguments:

  * `self` → access blockchain attributes.
  * `previous_proof` → element from last block, used to define the new puzzle.

---

## Step-by-Step Process

1. **Initialize Variables**

   * `new_proof = 1` → starting point.
   * `check_proof = False` → tracks whether the solution is found.

2. **While Loop**

   * Continue until `check_proof` becomes `True`.
   * Increment `new_proof` at each iteration.
   * Trial-and-error approach to finding correct proof.

3. **Define the Problem**

   * Use SHA256 cryptographic hash function.
   * Create an operation involving `new_proof` and `previous_proof`:

     -------------------code----------------------
     new_proof^2 - previous_proof^2
     -------------------code----------------------
   * Convert to string, encode, then apply SHA256 → `hash_operation`.
   * Convert result to hexadecimal with `.hexdigest()` → 64-character string.

4. **Difficulty Requirement**

   * Check if the first four characters of `hash_operation` are `"0000"`.
   * This is called the **four leading zeroes rule**.
   * More leading zeroes → more difficult.

5. **Condition**

   * If hash starts with `"0000"`:

     * `check_proof = True` (solution found).
   * Else:

     * Increment `new_proof` and repeat.

6. **Return**

   * Once found, return `new_proof`.
   * This proof will be used in the `create_block` function.

---

## Code Example

-------------------code----------------------
import hashlib

class Blockchain:

    def proof_of_work(self, previous_proof):
        new_proof = 1
        check_proof = False

        while check_proof is False:
            # Operation: non-symmetrical for uniqueness
            operation = str(new_proof**2 - previous_proof**2).encode()
            hash_operation = hashlib.sha256(operation).hexdigest()

            if hash_operation[:4] == "0000":
                check_proof = True
            else:
                new_proof += 1

        return new_proof
-------------------code----------------------

---

## Key Takeaways

* **Non-symmetrical operation** (e.g., `new_proof^2 - previous_proof^2`) avoids repetition of proofs.
* **Difficulty control**: the number of leading zeroes defines how hard the puzzle is.
* **Returned proof**: directly used by `create_block` to generate a valid new block.

---


*** 22. Step 7 ***
---

# Lecture Notes: Hash Function for Blockchain Validation

## Purpose

* We need a way to **check if the blockchain is valid**.

* Two essential checks:

  1. **Proof of Work Validity**: Each block must have a proof of work whose hash starts with four leading zeros.
  2. **Chain Integrity**: Each block’s `previous_hash` must equal the actual hash of the previous block.

* To perform the second check efficiently, we need a **hash function** that computes the SHA256 hash of any given block.

---

## Hash Function Design

### Function Name

* `hash` → a method inside the `Blockchain` class.

### Arguments

* `self` → reference to the blockchain instance.
* `block` → the block to be hashed (a dictionary).

### Process

1. **Convert Dictionary to String**

   * Blocks are dictionaries with keys:

     * `index`
     * `timestamp`
     * `proof`
     * `previous_hash`
   * Convert dictionary to a JSON string using `json.dumps(block, sort_keys=True)`.
   * Reason: ensures consistent ordering of keys and compatibility with JSON format.

2. **Encode the String**

   * Use `.encode()` to convert the string to bytes, since SHA256 requires bytes.

3. **Hash the Encoded Block**

   * Pass the encoded block to `hashlib.sha256()`.
   * Convert result to hexadecimal with `.hexdigest()`.

4. **Return the Hash**

   * Final output is a string representing the cryptographic hash of the block.

---

## Code Example

-------------------code----------------------
import hashlib
import json

class Blockchain:

    def hash(self, block):
        # Step 1: Convert dictionary to JSON string
        encoded_block = json.dumps(block, sort_keys=True).encode()
        
        # Step 2 & 3: Hash using SHA256
        block_hash = hashlib.sha256(encoded_block).hexdigest()
        
        # Step 4: Return hash
        return block_hash
-------------------code----------------------

---

## Key Takeaways

* **Why JSON instead of str()?**
  JSON ensures that the format is consistent and matches how blocks will be stored later.

* **Why `sort_keys=True`?**
  Guarantees the same block always produces the same hash, regardless of dictionary ordering.

* **Output Format**:
  A **64-character hexadecimal string** that uniquely identifies the block’s content.

---

This function now allows us to:

* Verify chain integrity.
* Build the upcoming `is_chain_valid` function to check the entire blockchain.

---


*** 23. Step 8 ***
---

# Lecture Notes: Blockchain Validation Function (`is_chain_valid`)

## Purpose

The function `is_chain_valid` ensures that the blockchain is correct and unaltered.
It performs two main checks:

1. **Hash Link Integrity**

   * Each block’s `previous_hash` must equal the actual hash of the previous block.

2. **Proof of Work Validity**

   * Each block’s proof must satisfy the proof-of-work requirement (its hash operation must start with four leading zeros).

---

## Function Definition

* Defined as a method in the `Blockchain` class.
* Signature:

  -------------------code----------------------
  def is_chain_valid(self, chain):
  -------------------code----------------------
* Arguments:

  * `self`: reference to the blockchain instance.
  * `chain`: the blockchain (list of blocks) to validate.

---

## Steps

### 1. Initialization

* `previous_block` = the first block of the chain (`chain[0]`).
* `block_index` = 1 (since the first block is already referenced as `previous_block`).

### 2. Loop Through the Chain

* Use a **while loop**:

  -------------------code----------------------
  while block_index < len(chain):
  -------------------code----------------------
* Iterate until all blocks are checked.

---

### 3. First Check: Previous Hash Validity

* Get the **current block**:

  -------------------code----------------------
  block = chain[block_index]
  -------------------code----------------------
* Compare `block['previous_hash']` with `self.hash(previous_block)`.
* If different → return `False` (chain invalid).

---

### 4. Second Check: Proof of Work Validity

* Get `previous_proof = previous_block['proof']`.
* Get `proof = block['proof']`.
* Compute the hash operation:

  -------------------code----------------------
  hash_operation = hashlib.sha256(str(proof**2 - previous_proof**2).encode()).hexdigest()
  -------------------code----------------------
* If the first 4 characters of `hash_operation` are not `"0000"` → return `False`.

---

### 5. Update Variables

* Update `previous_block = block`.
* Increment `block_index += 1`.

---

### 6. Final Return

* If all checks pass → return `True` (chain is valid).

---

## Example Code

-------------------code----------------------
import hashlib

class Blockchain:

    def is_chain_valid(self, chain):
        previous_block = chain[0]
        block_index = 1

        while block_index < len(chain):
            block = chain[block_index]

            # Check 1: Previous hash
            if block['previous_hash'] != self.hash(previous_block):
                return False

            # Check 2: Proof of work
            previous_proof = previous_block['proof']
            proof = block['proof']
            hash_operation = hashlib.sha256(str(proof**2 - previous_proof**2).encode()).hexdigest()

            if hash_operation[:4] != '0000':
                return False

            # Update for next iteration
            previous_block = block
            block_index += 1

        return True
-------------------code----------------------

---

## Key Takeaways

* **Two checks are mandatory**: hash linkage and proof validation.
* If any block fails validation, the function immediately returns `False`.
* If the loop completes with no issues, the chain is valid (`True`).

---

This concludes **Part 1: Building the Blockchain**.
Next step: **Part 2 – Mining the Blockchain** (handling requests to mine blocks and display the chain).

---


*** 24. Step 9 ***
---

# Lecture Notes: Part 2 – Mining the Blockchain (Flask Setup)

## Overview

* Transition from **Part 1 (Building the Blockchain)** to **Part 2 (Mining the Blockchain)**.
* Goal: interact with the blockchain through a **Flask-based web application** using GET requests in Postman.

---

## Four Main Steps in Part 2

1. **Create the Flask Web Application**

   * Use Flask to build a web server.

2. **Create the Blockchain**

   * Instantiate the Blockchain class to produce a working blockchain object.

3. **Mine a Block (GET Request)**

   * Add a new block by solving the proof-of-work problem.

4. **Get the Full Chain (GET Request)**

   * Retrieve and display the entire blockchain.

---

## Today’s Focus

* **Step 1:** Create the Flask application.
* **Step 2:** Create the blockchain instance.
* Both tasks are quick (just a few lines of code).

---

## Flask Quickstart

* Flask allows creation of lightweight web applications.

* To start:

  -------------------code----------------------
  from flask import Flask
  app = Flask(__name__)
  -------------------code----------------------

* Why `__name__`?

  * Required when using a single Python module.

* Later, routes (`@app.route`) will define endpoints such as:

  * `/mine_block`
  * `/get_chain`

---

## Creating the Blockchain

* Import and instantiate the Blockchain class:

  -------------------code----------------------
  blockchain = Blockchain()
  -------------------code----------------------
* This `blockchain` object represents the **real blockchain** you’ll interact with.

---

## Example Code

-------------------code----------------------
from flask import Flask
from blockchain import Blockchain   # Assuming your class is in blockchain.py

# Step 1: Create the web app
app = Flask(__name__)

# Step 2: Create the blockchain
blockchain = Blockchain()
-------------------code----------------------

---

## Key Takeaways

* Flask is the bridge between your blockchain and user interaction (via Postman).
* You now have:

  * A **web app (`app`)** to handle requests.
  * A **blockchain object (`blockchain`)** representing your actual blockchain.
* Next steps:

  * Add routes to mine blocks and display the chain.

---
