*** 16. Step 1 ***
# Practical Activities Course: Blockchain, Cryptocurrency, Smart Contracts

## Instructors

* Adla (second instructor for the course)

## Course Overview

This course contains **three main modules**:

1. **Module 1: Blockchain**

   * Create a general blockchain.
   * Each block can store arbitrary data.

2. **Module 2: Cryptocurrency**

   * Start from the blockchain created in Module 1.
   * Decentralize it across multiple computers/servers.
   * Create a cryptocurrency called **AT Coin**.

3. **Module 3: Smart Contracts**

   * Create a smart contract for a simulated ICO of 1 million AT Coins.

---

## Required Tools

* **Anaconda IDE** (recommended for Python 3.6 development)

  * Includes Spyder IDE and Jupyter Notebook.
  * Useful for practical tutorials.
* **Python 3.6** (not Python 2.7, due to syntax compatibility)
* **Packages**:

  * `flask` (for creating web-based blockchain API)
  * `requests` (for sending requests such as mining blocks or adding transactions)
* **Postman**

  * User-friendly HTTP client for interacting with the blockchain.
  * Alternative: cURL (less user-friendly for beginners)

---

## Step 1: Installing Anaconda

1. Go to the [Anaconda website](https://www.anaconda.com/) and download the installer.
2. Select the installer for your operating system (Windows, Linux, Mac).
3. Choose **Python 3.6** version.
4. Run the installer:

   * Click through `Continue → Continue → Agree → Install`.
   * Wait for installation to complete.

---

## Step 2: Launching Anaconda

* **Windows/Linux:** Find Anaconda Navigator in the program list.
* **Mac:** Find Anaconda Navigator in Applications.
* Launch it and wait for initialization.

### Inside Anaconda

* Work in the **root environment** (no need for a virtual environment for this course).
* Recommended IDE for practical use: **Spyder**

  * Jupyter Notebook is better for combining code with LaTeX/mathematical notation.
* Launch Spyder through Anaconda Navigator.

---

## Step 3: Preparing Your Project

1. Create a main folder, e.g., `blockchain_a-z`, with three subfolders:

   * `Module 1` → Blockchain
   * `Module 2` → Cryptocurrency
   * `Module 3` → Smart Contracts
2. Create a new Python file:

   * `File → New File`
   * Save as `blockchain.py` inside `Module 1` folder.
3. Close default `10.py` file in Spyder (not needed).
4. This `blockchain.py` will contain the implementation of the **general blockchain**.

---

## Step 4: Next Steps

1. Install the necessary Python packages:

   * `flask`
   * `requests`
2. Set up **Postman** to interact with your blockchain API.
3. Begin implementing the general blockchain in `blockchain.py`:

   * Create plain blocks
   * Enable adding arbitrary data to blocks

**Next Tutorial:** Installing packages and preparing Postman for blockchain interaction.

---

*** 17. Step 2 ***

# Lecture Notes – Installing Tools for Blockchain Development

## Introduction

* Before creating the blockchain, two tools must be installed:

  1. **Flask** – A web framework to build a web application containing the blockchain.
  2. **Postman** – An HTTP client providing a user-friendly interface for interacting with the blockchain (instead of CURL).

---

## Installing Flask

* **Command:**

-------------------code----------------------
pip install Flask==0.12.2
-------------------code----------------------

  PS: we use "pipenv install" instead

* **For Mac/Linux:**
  Open a terminal and run the command.

* **For Windows:**

  * Click the Windows button (bottom left).
  * Search for *Anaconda* → *Anaconda Prompt*.
  * Run the command inside the prompt.

* **Notes:**

  * If Flask is already installed, it will show up.
  * If not, installation is quick.

---

## Installing Postman

* **Steps:**

  1. Open a browser and search for *Postman*.
  2. Click the official link: *Postman API Development Environment*.
  3. Download for your operating system (Mac, Windows, Linux).
  4. The download begins automatically (small file size).
  5. Locate the downloaded file (e.g., *Postman OSX* on Mac).
  6. Double-click to unzip and run the installer.

* **First Use:**

  * Sign up with Google or create an account.
  * Once signed in, the main interface shows available request types.

---

## Using Postman

* **Request Types Used:**

  * **GET Request:**

    * Retrieve the state of the blockchain.
    * Mine a block.
  * **POST Request:**

    * Add a new transaction (will be used in module two).
    * Requires a JSON file with:

      * Sender address
      * Receiver address
      * Amount of AT coins

* **Note:**

  * Module one uses only **GET requests** (mining blocks, checking blockchain state).
  * Module two introduces **POST requests** for transactions (with AT coin).

---

## Conclusion

* Flask and Postman are now installed.
* With these tools ready, development of the blockchain (module one) can begin.

---

*** 18. Step 3 ***
---

# Lecture Notes – Building the Blockchain (Part 1)

## Overview

* The blockchain will be built in **two parts**:

  1. **Part 1** – Build the blockchain architecture (class and structure).
  2. **Part 2** – Add two functions:

     * Function to get the state of the blockchain (display in Postman).
     * Function to mine a new block.

* In this lecture: focus on **Part 1 – Building the blockchain architecture**.

---

## Libraries Imported

1. **datetime** – To generate timestamps for each block (date and time of creation/mining).
2. **hashlib** – To hash blocks using SHA-256 (ensures data integrity).
3. **json** – To encode blocks before hashing (using `json.dumps`).
4. **Flask** – Web framework to create the blockchain application.

   * `Flask` class: creates the web application.
   * `jsonify`: formats responses into JSON for Postman.

---

## Purpose of `jsonify`

* Converts responses into JSON format for Postman.
* Used in:

  * Displaying the blockchain state.
  * Returning details of a newly mined block (index, proof, previous hash, and message).

---

## Why Use a Class?

* A **class** is the best way to build a scalable and organized system like a blockchain.
* Benefits of classes:

  * Encapsulate **properties**, **functions**, and **methods**.
  * Allow creation of multiple objects (instances).
  * Provide structure and modularity.
* Example: a self-driving car class with properties (speed, sensors) and methods (move forward, turn, brake).
* Similarly, a blockchain class will encapsulate all the core components.

---

## Defining the Blockchain Class

* Start with:

  -------------------code----------------------
  class Blockchain:
  -------------------code----------------------
* Inside the class, include all blockchain components:

  * **Genesis block** (first block of the chain).
  * **Chain initialization** (list of blocks).
  * **`create_block` method** (to add new blocks).
  * Additional tools to ensure blockchain security and integrity.

---

## `__init__` Method

* Always defined when working with classes.
* Syntax:

  -------------------code----------------------
  def __init__(self):
  -------------------code----------------------
* Argument: `self` (refers to the object instance created from the class).
* Responsibilities:

  1. **Initialize the chain**:

     -------------------code----------------------
     self.chain = []
     -------------------code----------------------

     * Creates an empty list to store blocks.
  2. **Create the Genesis block**:

     -------------------code----------------------
     self.create_block(proof=1, previous_hash='0')
     -------------------code----------------------

     * **Proof:** Arbitrary starting value (commonly `1`).
     * **Previous hash:** Arbitrary since no block precedes the Genesis block (commonly `'0'`).
     * Must be a string (because SHA-256 accepts encoded strings).

---

## Current Progress

* The blockchain is initialized with:

  * An empty list (`self.chain`).
  * A Genesis block (created using the `create_block` method).

* Next step (in future lecture): implement the `create_block` method to add blocks.

---


*** 19. Step 4 **
---

# Lecture Notes: Create Block Function in Blockchain

## Recap from Previous Tutorial

* Initialized blockchain with two variables:

  * `self.chain`: an empty list that will store mined blocks.
  * Genesis block: created with `create_block` function using:

    * `proof = 1`
    * `previous_hash = "0"`

---

## Purpose of the Create Block Function

* Used **right after mining a block**.
* Creates and appends a new block to the blockchain.
* Key difference from `mine_block` function:

  * `mine_block`: finds the **proof of work** (solves the puzzle).
  * `create_block`: takes that proof and previous hash to form and store the new block.

---

## Function Arguments

* `self`: to access blockchain object variables.
* `proof`: obtained after solving the proof of work.
* `previous_hash`: the hash of the previous block, linking blocks together.

---

## Block Structure

Each block is a dictionary with four essential keys:

1. **Index**

   * Position of the block in the chain.
   * `index = len(self.chain) + 1`

2. **Timestamp**

   * Exact time when the block is mined.
   * Obtained using:

     -------------------code----------------------
     str(datetime.datetime.now())
     -------------------code----------------------

3. **Proof**

   * The proof of work found by solving the algorithm.
   * Passed as an argument to the function.

4. **Previous Hash**

   * The hash of the previous block.
   * Ensures continuity and immutability of the blockchain.

---

## Optional Additional Key

* **Data**:

  * Can store transactions or other information.
  * Example: `"data": "some text or structured content"`
  * This will be expanded in Module 2 (cryptocurrency transactions).

---

## Appending and Returning the Block

* After defining the block:

  * Append it to the chain with `self.chain.append(block)`
  * Return the block so its information can be displayed (e.g., in Postman).

---

## Workflow Summary

1. Mine block → solve proof of work.
2. Call `create_block(proof, previous_hash)` → generate block.
3. Append new block to blockchain.
4. Return block details for display.

---
